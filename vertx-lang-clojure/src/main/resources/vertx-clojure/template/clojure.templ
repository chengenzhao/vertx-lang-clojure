(ns io.@{type.raw.moduleName}.clojure.@{type.raw.getSimpleName(CASE_KEBAB)})\n
@code{
    /*clojure does not allow different functions with the same name, thus combine the functions with the same name first
    use their name as map key, methods as value list*/
    import java.util.TreeMap;
    import java.util.HashSet;

    var methodsMap = new TreeMap();
    var importClassSet = new HashSet();
    foreach (method : methods) {
        if(methodsMap[method.name] == null){
            methodsMap[method.name] = [method]
        }else{
            /*Can't have 2 overloads with same arity, the second method with same name and params numbers will be add hyphen at the end of method name*/
            var thereIsAnExistingMethodWithSameParameterNumber = false;
            for( mtd:methodsMap[method.name] ){
                if(mtd.params.size() == method.params.size()){
                    thereIsAnExistingMethodWithSameParameterNumber = true;
                }
            }
            if(!thereIsAnExistingMethodWithSameParameterNumber){
                methodsMap[method.name].add(method)
            }else{
                methodsMap[method.name + "-" ] = [method]
            }
        }
        foreach(param:method.params){
            if(param.type.getName().startsWith("io.vertx.")||param.type.getName().startsWith("java.util.")){
                importClassSet.add(param.type.raw)
            }
        }
    }

}
\n(import @{type.raw})
@foreach{clazz:importClassSet}
\n(import @{clazz})
@end{}
\n
@foreach{methodName:methodsMap.keySet()}

\n(defn @{CASE_KEBAB.format(CASE_CAMEL.parse(methodName))}

@foreach{method:methodsMap[methodName]}\n  (
@if{method.name == type.raw.getSimpleName()}[@foreach{param:method.params}@{CASE_KEBAB.format(CASE_CAMEL.parse(param.name))}@end{' '}] (
new @{type.raw.getSimpleName(CASE_KEBAB)}(@foreach{param:method.params}@{CASE_KEBAB.format(CASE_CAMEL.parse(param.name))}@end{' '}
)
@else{method.staticMethod}[@foreach{param:method.params}@{CASE_KEBAB.format(CASE_CAMEL.parse(param.name))}@end{' '}] (
@{type.raw.getSimpleName}/@{method.name} @foreach{param:method.params}@{CASE_KEBAB.format(CASE_CAMEL.parse(param.name))}@end{' '}
)
@else{}[@{type.raw.getSimpleName(CASE_KEBAB)} @foreach{param:method.params}@{CASE_KEBAB.format(CASE_CAMEL.parse(param.name))}@end{' '}] (
.@{method.name} @{type.raw.getSimpleName(CASE_KEBAB)} @foreach{param:method.params}@{CASE_KEBAB.format(CASE_CAMEL.parse(param.name))}@end{' '}
)
@end{})
@end{})
@end{}
